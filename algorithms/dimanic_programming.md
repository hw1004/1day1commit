# 다이나믹 프로그래밍 (동적 계획법)
> 메모리를 적절히 사용하여 수행 시간 효율성을 향상시키는 방법
> 이미 계산된 작은 결과는 별도의 메모리 영역에 저장하여 두번 계산하지 않도록 함.

- 다이나믹 프로그래밍의 사용조건
    1. 최적 부분 구조 (Optimal Substructure)
        - 큰 문제를 작은 문제로 나누어 해결 할 수 있음
    2. 중복되는 부분 문제 (Overlapping Subproblem)
        - 동일한 작은 문제를 반복적으로 해결해야 할 때

- 예시: 피보나치 수열
  - **점화식**: 인접한 항들 사이의 관계식
    - a(n) = a(n-1) + a(n-2), a(1) = 1, a(2) = 1
    - a(4) = a(3) + a(2) = (a(2) + a(1)) + a(2)
```
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n-1) + fibo(n-2)
```
- 위와 같이 재귀 함수로 피보나치 문제를 해결하면 f(2)와 같은 중복되는 부분 문제가 여러번 호출되는 문제가 발생한다.

- 별도의 메모리 공간에 이미 해결한 문제를 기록해 놓아야 함

## 1. 탑다운(메모이제이션 (Memoization) - 하향식)
- 하향식으로 다이나믹 프로그래밍을 구현하는 방법
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법
- **캐싱**: 값을 기록해 놓는다.
- 이전에 계산된 결과를 일시적으로 기록해 놓는 *넓은* 개념 (다이나믹 프로그래밍을 위해 활용되지 않을 수도 있음)

## 2. 보텀업(상향식)
- 다이나믹 프로그래밍의 전형적 형태
- **DP 테이블**: 결과 저장용 리스트


- 다이나믹 프로그래밍을 이용한 피보나치 수열 해결 법
1. 탑다운
```
d = [0]*100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    # 계산되었던 문제라면 초기화된 d list에 fibo 값을 계산해서 기록해 놓음
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
```
2. 보텀업
```
# DP 테이블
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]
```


## 다이나믹 프로그래밍과 분할 정복
- 둘 다 최적 부분 구조를 가질 때 사용 (큰 문제를 작은 문제 여러개로 해결)
- 다이나믹 프로그래밍은 부분 문제가 중복되지만 분할 정복 문제는 동일한 부분 문제가 반복적으로 계산되지 않음
- **퀵 정렬**: 분할 정복의 예시 (분할 이후 한 번 해결한 기준 원소 문제를 다시 호출하지 않음)
